# 🚀 线性递推式求解大师 🚀

## 📖 背景故事：小H的挑战

小H是一名充满好奇心的大学生，他的弟弟正在上小学。暑假将至，小H回想起了自己被小学数学中那些"找规律"题目支配的"恐惧" (😱)。为了不再重蹈覆辙，并帮助弟弟（顺便展示一下大学所学），小H决定运用《算法导论》的知识，彻底攻克这类难题！

## 🎯 问题核心：寻找数列的秘密

给定一个包含 `n` 个数字的序列 `s₀, s₁, ..., s_{n-1}`，我们的任务是：
1. 找出这个序列的 **最短线性递推式**。
2. 基于这个递推式，计算出序列的第 `m` 项 `s_{m-1}` (这里的 `m` 可能会非常大！🤯)。

**💡 重要提示：** 线性递推式可能不唯一，但我们追求的是那个最简洁、最短的！

### 🔍 什么是线性递推式 & 最短线性递推式？

**线性递推式**：
这是一种描述数列中各项之间线性关系的数学工具。对于一个数列 `{aₙ}`，其 `k` 阶线性递推式可以表示为：
```
aₙ = c₁·a_{n-1} + c₂·a_{n-2} + ... + cₖ·a_{n-k},  对于 n ≥ k
```
其中 `c₁, c₂, ..., cₖ` 是常数系数，且 `cₖ ≠ 0`。

**最短线性递推式**：
顾名思义，就是在所有能够描述给定数列的线性递推式中，阶数（`k` 值）最小的那一个。它是序列的"指纹"，简洁而独特！

## ✨ 一睹为快：经典示例

* 🔢 **累加数列**: `s = [1, 2, 3, 4, 5]`
  * 秘密公式: `sₙ = 2·s_{n-1} - s_{n-2}`
  * 第100项 (`s₉₉`): `100`

* ✖️ **累乘数列**: `s = [1, 2, 4, 8, 16]` (等比数列)
  * 秘密公式: `sₙ = 2·s_{n-1}`
  * 第100项 (`s₉₉`): `2⁹⁹` (一个巨大的数字!)

* 🐰 **斐波那契数列**: `s = [0, 1, 1, 2, 3]`
  * 秘密公式: `sₙ = s_{n-1} + s_{n-2}`
  * 第100项 (`s₉₉`): `354224848179261915075`

## 🛠️ 算法兵器库：我们的解决方案

### 🔑 第一步：揭示递推关系

#### 1. 🚀 Berlekamp-Massey (BM) 算法 - 速度与智慧的结合！
BM算法是寻找最短线性递推式的"王牌武器"。它巧妙、高效，广泛应用于编码理论等高精尖领域。
* **核心思想**：采用贪心策略，逐个扫描序列元素，动态构建并修正当前的最短递推式。
* **时间复杂度**: `O(N²)` - 非常快！
* **空间复杂度**: `O(N)` - 很节省！

#### 2. 📐 高斯消元法 - 经典永不褪色！
这是一种更为传统和直观的方法，通过解线性方程组来确定递推系数。
* **核心思想**：将寻找递推关系的问题转化为求解 `A·x = b` 的线性方程组。
* **时间复杂度**: `O(N⁴)` (最坏情况) - 对于大规模数据可能较慢。
* **空间复杂度**: `O(N²)`

### ⏱️ 第二步：闪电计算第 `m` 项

一旦我们掌握了递推式 (设其阶数为 `L`)，就有多种"加速器"来计算遥远的第 `m` 项：

#### 🧱 方法一：矩阵快速幂 - 稳健可靠
将递推关系转化为矩阵乘法，然后利用快速幂技巧加速。
* **时间复杂度**: `O(L³ log m)`
* **空间复杂度**: `O(L²)`

#### 📜 方法二：多项式快速幂 - 轻巧敏捷
在多项式层面进行操作，同样结合快速幂。
* **时间复杂度**: `O(L² log m)`
* **空间复杂度**: `O(L)`

#### ⚡ 方法三：FFT/NTT 优化 - 终极加速！
利用快速傅里叶变换 (FFT) 或数论变换 (NTT) 来优化多项式乘法，实现惊人的速度提升！
* **时间复杂度**: `O(L log L log m)` - 目前最优！
* **空间复杂度**: `O(L)`

## 📊 性能大比拼：复杂度概览

| 算法 | 单次运算 | 总体复杂度 | 空间复杂度 |
|------|----------|------------|------------|
| 🐢 直接递推 | `O(L)` | `O(L·m)` | `O(L)` |
| 🧱 朴素矩阵快速幂 | `O(L³)` | `O(L³ log m)` | `O(L²)` |
| 📜 朴素多项式快速幂 | `O(L²)` | `O(L² log m)` | `O(L)` |
| ✨ FFT优化多项式 | `O(L log L)` | `O(L log L log m)` | `O(L)` |
| ⚡ NTT优化多项式 | `O(L log L)` | `O(L log L log m)` | `O(L)` |

## 📁 项目文件结构一览

```
.
├── 📜 berlekamp_massey.cpp      # NTT优化的BM算法实现
├── 📐 gaussian_elimination.cpp  # 高斯消元法求递推式实现
├── 🧱 matrix_power.cpp          # 矩阵快速幂算法实现
├── 📜 poly_multiply.cpp         # 多项式乘法优化算法实现
├── 🐢 naive.cpp                 # 朴素算法实现
├── 🧪 test1.bat                 # Windows评测脚本1(BM vs 高斯)
├── 🐧 test1.sh                  # Linux评测脚本1(BM vs 高斯)
├── 🧪 test2.bat                 # Windows评测脚本2(全算法测试)
├── 🐧 test2.sh                  # Linux评测脚本2(全算法测试)
├── 📁 in/                       # 输入测试用例目录
└── 📁 out/                      # 标准答案目录
```

## 🚀 快速开始：使用指南

### 🐧 Linux/Unix 用户

1. **评测求解线性递推式算法**:
   ```bash
   chmod +x test1.sh
   ./test1.sh
   ```

2. **评测计算第m项的算法**:
   ```bash
   chmod +x test2.sh
   ./test2.sh
   ```

### 💻 Windows 用户

#### 手动编译和运行 (推荐方式)

1. **编译所有算法实现**:
   ```cmd
   g++ -std=c++11 -O2 berlekamp_massey.cpp -o berlekamp_massey_exec
   g++ -std=c++11 -O2 gaussian_elimination.cpp -o gaussian_elimination_exec
   g++ -std=c++11 -O2 matrix_power.cpp -o matrix_power_exec
   g++ -std=c++11 -O2 poly_multiply.cpp -o poly_multiply_exec
   g++ -std=c++11 -O2 naive.cpp -o naive_exec
   ```

2. **运行单个测试用例**:
   ```cmd
   REM BM算法测试
   berlekamp_massey_exec < in\1.in > result1.out
   
   REM 高斯消元测试
   gaussian_elimination_exec < in\1.in > result2.out
   
   REM 比较结果
   fc result1.out out\test1.out
   fc result2.out out\test1.out
   ```

3. **比较两种方法**:
   - 分别运行BM算法和高斯消元法
   - 比较它们的输出结果和运行时间
   - 对于大规模数据，BM算法通常更快

4. **评测求解第m项的算法** (手动依次测试各种方法):
   ```cmd
   REM 对同一输入测试不同方法
   berlekamp_massey_exec < in\test2.in > bm_result.out
   matrix_power_exec < in\test2.in > matrix_result.out
   poly_multiply_exec < in\test2.in > poly_result.out
   naive_exec < in\test2.in > naive_result.out
   
   REM 比较结果
   fc bm_result.out out\test2.out
   ```

## 📝 输入/输出格式

### 📥 输入格式
```
n m
s₀ s₁ ... s_{n-1}
```
* 第一行：两个整数 `n` 和 `m`，表示给定序列长度和要求的项数
* 第二行：`n` 个整数，表示序列 `s₀, s₁, ..., s_{n-1}`

### 📤 输出格式
```
s_{m-1}
```
* 一个整数，表示序列的第 `m` 项 `s_{m-1}`

## ✨ 数据规模性能分析

* **🟢 小规模数据** (n≤10, m≤100): 所有算法都能快速处理，差异不明显
* **🟡 中规模数据** (n≤100, m≤10K): BM算法开始显现优势
* **🔴 大规模数据** (n≤1K, m≤1M): BM算法优势明显，高斯消元可能超时
* **💥 超大规模数据** (n>1K, m>1M): 强烈推荐BM+NTT算法

---

> *"数学的本质，就是看似复杂的现象背后隐藏着简单优雅的规律。"* ✨
